[
  {
    "id": "bs0-i_8fab",
    "type": "header",
    "data": {
      "text": "Mediapipe",
      "level": 2
    },
    "index": 0,
    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1",
    "crdts": {
      "operations": [
        [
          {
            "creator": "fgdfoknmow",
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "id": "bs0-i_8fab",
                    "type": "header",
                    "data": {
                      "text": "",
                      "level": 2
                    },
                    "index": 0,
                    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1"
                  }
                }
              }
            ],
            "time": 1684898446851.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "text": "X",
                      "level": 2
                    },
                    "index": 0,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898447666.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "text": "Mediapipe",
                      "level": 2
                    },
                    "index": 0,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898450370.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898972229.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899100834.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899356489.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899852045.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899887524.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899912581.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900008682.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900559254.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900896076.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901008305.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901066558.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901103550.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901158070.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901201122.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901227290.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901304268.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901557115.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902845090.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902997948.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903111694.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903504184.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903680249.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903870658.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904261732.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906010430.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 0
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906271850.01
          }
        ]
      ],
      "hash": "05f2ceac8d6d8cc476dc84f0215435ebe42580317191bb9fb849f1db4aad14ef"
    },
    "_meta": {
      "lwt": 1684906271860.01
    },
    "_deleted": false,
    "_attachments": {},
    "_rev": "30-qwmnxojdkk"
  },
  {
    "id": "61x4H6mw3Z",
    "type": "code",
    "data": {
      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        connection.send({topic: \"\", message: distance > 0 ? \"l\" : \"r\"});\n      })\n    )\n  )\n)",
      "language": "javascript",
      "output": ""
    },
    "index": 1,
    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1",
    "crdts": {
      "operations": [
        [
          {
            "creator": "fgdfoknmow",
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "id": "61x4H6mw3Z",
                    "type": "code",
                    "data": {
                      "code": "",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1"
                  }
                }
              }
            ],
            "time": 1684906211997.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906214725.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906223691.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid$",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906224251.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid$.pipe(\n  \n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906226483.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906228108.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "undefined"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906231187.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906260099.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906271961.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906681460.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const conn\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906684875.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = \n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906686651.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = conn\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906689611.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = co\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906691771.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = conec\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906692700.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect()\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906695619.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906712107.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n      hostname: \"test.mosquitto.org\",\n      port: 8080,  \n      path: '/', \n      topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n      protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906713364.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n      hostname: \"test.mosquitto.org\",\n  port: 8080,  \n      path: '/', \n      topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n      protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906717171.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n      path: '/', \n      topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n      protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906718844.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n      topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n      protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906720171.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n      protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906721971.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n      //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906723571.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n      //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906724923.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n  //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906726179.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n  //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906732091.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...m\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n  //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906733100.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  hostname: \"test.mosquitto.org\",\n  port: 8080,  \n  path: '/', \n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n  //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906736380.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n  protocol: \"ws\"\n  //username: \"\", \n  //password: \"\"\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906743771.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1',\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906745068.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n})\n\n\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906745708.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n})\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906748211.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).share\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906750853.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).shareRepla\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906752491.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(share)\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906755436.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareRelay)\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906756875.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1))\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906758804.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906759627.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\n\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906815883.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906816876.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906860564.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906861204.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(x)\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906865332.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906866452.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map()\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906868204.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(())\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906868667.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([]))\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906869147.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]))\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906871123.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n\n  })\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906873972.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  })\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906875787.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906878588.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]) => {\n    const distance = visionLine-x;fafafa\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907255588.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  map(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907256708.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  ma(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907267579.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  con(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907268747.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907270436.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return \n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907273412.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907276524.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe()\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907278284.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      \n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907279619.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      con\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907281348.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      \n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907282589.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      send\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907284364.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      sendO\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907285324.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907288420.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x =.)\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907293212.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'a42ff66c-9b52-4804-8220-5d0944168fbc-1'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907294068.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: '\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907297571.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: ''\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907298747.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'herm'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907302172.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'h'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907303388.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n      sendOverProtocol\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907304620.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n    return connection.pipe(\n      map(x => )\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907310716.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    \n    return connection.pipe(\n      map(x => )\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907313316.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => {\n    return connection.pipe(\n      map(x => )\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  }),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907315380.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    return connection.pipe(\n      map(x => )\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907318332.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => )\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907321700.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        \n      })\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907331164.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n    const relativeDistance = Math.abs(distance)/x;\n      })\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907331820.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n      })\n    )\n    return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907333612.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n      })\n    )\n\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907337268.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n      })\n    )\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907338756.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  ),\n  rewrite()\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907339436.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907344548.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        \n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907368612.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907369903.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold) \n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907370668.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            \n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907372172.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907373692.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        \n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907381300.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      \n      map(x => {\n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907383260.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x =)\n      map(x => {\n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907384812.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      map(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907387620.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        return relativeDistance <= threshold ? \"NONE\" : distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907410252.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907413980.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907415276.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap((x => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907420555.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap((x) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907421404.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(() => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907428196.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907430540.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connectio = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907436068.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst c = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907437420.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst c$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907438948.04
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907440668.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connectionconnection$pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907444471.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907444979.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907445868.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection. \n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907450828.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.pipe()\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907452556.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907461636.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907462116.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.send()\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907464596.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.send({topic: })\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907466252.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.send({topic: \"\"})\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907467164.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.send({topic: \"\", })\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907468940.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        distance > 0 ? \"l\" : \"r\";\n        connection.send({topic: \"\", message: })\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907473699.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        ;\n        connection.send({topic: \"\", message: })\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907474499.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n    \n        connection.send({topic: \"\", message: })\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907476188.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        connection.send({topic: \"\", message: distance > 0 ? \"l\" : \"r\"})\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907478556.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        connection.send({topic: \"\", message: distance > 0 ? \"l\" : \"r\"});\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": "0.6801594425650204,0.555013400666854,-0.7342492850387797"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907479892.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "const visionLine = 0.5;\nconst threshold = 0.2;\n\nconst connection$ = connect(\"MQTT\", {\n  ...environment.mqtt,\n  topic: 'x'\n}).pipe(shareReplay(1));\n\nenvironment.centroid$.pipe(\n  concatMap(([x,y,z]) => \n    connection$.pipe(\n      tap(({connection}) => {\n        const distance = visionLine-x;\n        const relativeDistance = Math.abs(distance)/x;\n        if (relativeDistance <= threshold)\n            return;\n        connection.send({topic: \"\", message: distance > 0 ? \"l\" : \"r\"});\n      })\n    )\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907530812.01
          }
        ]
      ],
      "hash": "401299c0534f2eac0799e44ec12bd3f284edb873dfb95fe4d5b216b4c89c46b2"
    },
    "_meta": {
      "lwt": 1684907530816.01
    },
    "_deleted": false,
    "_attachments": {},
    "_rev": "122-qwmnxojdkk"
  },
  {
    "id": "_J2HFFOtTq",
    "type": "code",
    "data": {
      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n          environment.centroid = calculateCentroid(result.landmarks[0])\n        );\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
      "language": "html",
      "output": ""
    },
    "index": 2,
    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1",
    "crdts": {
      "operations": [
        [
          {
            "creator": "fgdfoknmow",
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "id": "_J2HFFOtTq",
                    "type": "code",
                    "data": {
                      "code": "",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1"
                  }
                }
              }
            ],
            "time": 1684898453314.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "   <video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n        <canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898454050.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n        <canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898456882.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898458261.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898460649.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898463066.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898464378.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script>\n  \n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898465714.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type>\n  \n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898467762.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  \n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898470106.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n  PoseLandmarker,\n  FilesetResolver,\n  DrawingUtils\n} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898529186.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n  PoseLandmarker,\n  FilesetResolver,\n  DrawingUtils\n } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898531474.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898534986.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n  \n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898537170.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: runningMode,\n    numPoses: 2\n  });\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898554090.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: runningMode,\n    numPoses: 2\n  });\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898556218.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898560858.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElement;\nlet webcamRunning: Boolean = false;\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898594066.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElement;\n  let webcamRunning: Boolean = false;\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898594714.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElement;\n  let webcamRunning: Boolean = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898597168.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElement;\n  let webcamRunning: Boolean = fals;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898598002.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElement;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898600226.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton: HTMLButtonElemen;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898602290.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898603298.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n   const canvasElement = document.getElementById(\n  \"output_canvas\"\n) as HTMLCanvasElement;\nconst canvasCtx = canvasElement.getContext(\"2d\");\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898624738.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\n  \"output_canvas\"\n) as HTMLCanvasElement;\nconst canvasCtx = canvasElement.getContext(\"2d\");\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898625651.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\") as HTMLCanvasElement;\nconst canvasCtx = canvasElement.getContext(\"2d\");\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898627842.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898629570.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\"); \n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898630866.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898631994.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n   const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898677348.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let enableWebcamButton;\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898677963.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898700178.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n    video.srcObject = stream;\n    video.addEventListener(\"loadeddata\", predictWebcam);\n  });\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898711779.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  navigator.mediaDevices.getUserMedia(constraints).then((stream) => {\n    video.srcObject = stream;\n    \n  });\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898715986.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898719450.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898733706.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\") as HTMLVideoElement;\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898789818.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898798611.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898851434.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898852722.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898861123.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898862115.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  let lastVideoTime = -1;\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898896492.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898897547.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898905116.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  // Now let's start detecting the stream.\n  if (runningMode === \"IMAGE\") {\n    runningMode = \"VIDEO\";\n    await poseLandmarker.setOptions({ runningMode: \"VIDEO\" });\n  }\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898913851.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898915664.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898924282.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  \n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898925290.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898926170.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      for (const landmark of result.landmarks) {\n        drawingUtils.drawLandmarks(landmark, {\n          radius: (data) => DrawingUtils.lerp(data.from!.z, -0.15, 0.1, 5, 1)\n        });\n        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);\n      }\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898929986.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      \n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898935867.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898939408.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(reuslt)\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898950116.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898952595.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898954108.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    \n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898964018.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  // Call this function again to keep predicting when the browser is ready.\n  if (webcamRunning === true) {\n    window.requestAnimationFrame(predictWebcam);\n  }\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898964602.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898966442.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684898972336.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  let webcamRunning = false;\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899079778.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899086164.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899087914.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  video.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899092318.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899093338.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899100925.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899106011.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899108386.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {\n    PoseLandmarker,\n    FilesetResolver,\n    DrawingUtils\n} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n);\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: false\n});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899133133.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,\n    FilesetResolver,\n    DrawingUtils\n} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n);\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: false\n});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899147891.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n);\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: false\n});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899151234.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: false\n});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899154586.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\n  import {\n   PoseLandmarker,\n   FilesetResolver,\n   DrawingUtils\n  } from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\n   const vision = await FilesetResolver.forVisionTasks(\n    \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\"\n  );\n  const poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n      modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n      delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n  });\n  const videoHeight = \"360px\";\n  const videoWidth = \"480px\";\n  const video = document.getElementById(\"webcam\");\n  const canvasElement = document.getElementById(\"output_canvas\");\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n  video.srcObject = stream;\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n  let startTimeMs = performance.now();\n  if (lastVideoTime !== video.currentTime) {\n    lastVideoTime = video.currentTime;\n    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n      canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n      console.log(result);\n      canvasCtx.restore();\n    });\n  }\n\n  window.requestAnimationFrame(predictWebcam);\n}\n  video.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899182578.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899346562.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899356583.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result[]);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899384715.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result[0]);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899385659.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899386403.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n    window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899391506.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899392491.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\n  function calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899477165.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899479818.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899486122.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.land));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899496003.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899497413.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899510701.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid());\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899520723.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899522603.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899523741.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid());\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899532618.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899533674.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899539762.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(result.landmarks);\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899540370.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899541749.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n           const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n    ctx.beginPath();\n    ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n    ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899618355.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n      ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899624204.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n             ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899625387.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899625947.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899629395.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0])\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899639284.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            calculateCentroid(result.landmarks[0])\n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899643931.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            \n            const [x,y,z] = calculateCentroid(faceLandmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899645178.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            \n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899647859.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899648947.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899658986.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*ctx.canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899659814.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*canvas.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899661890.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvas.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899667914.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899670067.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ccanvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899671770.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899672819.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899674131.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            console.log(calculateCentroid(result.landmarks[0]));\n            canvasCtx.restore();\n        });\n    }\n\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899675434.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899682440.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899690802.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899691459.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899692637.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899722674.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899723810.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899754026.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899757558.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*ctx.canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            ctx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899758859.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            ctx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899759779.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            ctx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899760395.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899760867.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899762547.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899763332.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  \n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899766059.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899789795.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899792620.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            \n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899822997.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log()\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899825032.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(v)\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899826498.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid)\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899827489.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899829458.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899852208.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 5, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899861827.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899876786.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899887625.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899893179.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899894955.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899897534.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899912649.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899934931.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n  canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899935854.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899936907.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n  canvasElement.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899952700.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n  canvasElement.style.width = videoWidth;\n  video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899954180.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899956339.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\n  const videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899969875.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899970843.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899972812.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684899974601.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900008795.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n         canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900035147.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n         canvasCtx.save();\n         canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900035715.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n         canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900038388.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900039667.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n      canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900048827.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900049491.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n          canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900471195.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n             canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900472403.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900472932.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900474515.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900475235.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900477534.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        \n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900523666.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n          canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900525691.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900527220.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n        });\n        canvasCtx.restore();\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900531322.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900531824.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900532995.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900559375.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n  \n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900580995.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900581931.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900582595.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900618570.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900620307.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900627363.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900628920.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoHeight,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900745695.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoHeight,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900757493.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900763699.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900765299.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(ve)\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900784633.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vC)\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900785667.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid)\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900786899.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900787722.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900790635.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900802019.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900816971.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900819169.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900823513.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*3,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900843538.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*360,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900844160.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*360,y*videoHeigh];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900849235.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*360,y*];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900850376.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*360,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900856075.04
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z);\n            const vcentroid = [x*videoWidth,y*videoHeight];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900857690.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900860163.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();window.requestAnimationFrame(predictWebcam);\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900878980.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900880300.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900881075.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900882782.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900896190.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900900427.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n          ctx.fillStyle='black';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900934860.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='black';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900935812.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white\n              ';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900938028.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white\n          ';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900938651.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900939675.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            ctx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900941515.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900962496.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 100, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900968104.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684900969474.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901008420.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901010473.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901012220.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*480,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901044975.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901045668.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901046874.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*360];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901053515.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901053979.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901055180.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901066675.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901068200.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901069788.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n  canvasElement.width,\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901091183.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width,)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901094781.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901095415.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width):\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901096081.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901098369.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901103673.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = video;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901135299.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901135803.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901137507.04
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901138084.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901139862.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901151866.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901152641.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901153801.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901158180.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901171355.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n          \n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901181219.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            \n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901182059.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(v)\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901184411.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid)\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(canvasElement.style.width);\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901185443.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901186362.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901188097.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901201225.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n          \n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901211187.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901215708.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901217912.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901227400.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901251907.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"1280px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901270635.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"1280px\";\nconst videoWidth = \"128px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901273267.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"0px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901275387.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"70px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901276004.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 480px; height: 360px;\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 360px; width: 480px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"360px\";\nconst videoWidth = \"480px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            console.log(x,y,z)\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901276795.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901279531.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901281850.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901304387.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.widt,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901346323.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901347803.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y*canvasElement.];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901352507.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901353731.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901354445.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901356195.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901369924.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901434317.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901434859.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901436092.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901441816.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.w)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901442611.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901445331.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901557237.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901579500.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroi);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901620460.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log;\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901621220.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901625099.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901625643.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901626188.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901628252.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(x,y,z);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901649515.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901651227.04
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901739459.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901741763.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(result.landmarks[0]);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901743379.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901793216.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901794651.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            \n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901811931.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901812723.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n  \n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901816363.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    c\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901818715.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(lan)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901821708.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            console.log(vcentroid);\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901822259.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901824699.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901861924.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901864867.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901908868.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901978836.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684901980044.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902238715.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902241899.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n  \n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902251115.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result)\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n          \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902255316.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902257813.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n      \n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902663872.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        i\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902665575.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if ()\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902666599.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (lan)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902667328.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902667823.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[])\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902668711.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0])\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902669463.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] )\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902670471.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] >)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902674023.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902675479.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1 )\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902676087.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1 ||)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902676943.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1 || ac)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902679679.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1 )\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902681095.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark[0] > 1 ||)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902682047.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 ||)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902686024.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902690799.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 )\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902692558.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 |)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902693199.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || la)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902694759.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902696439.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902698391.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902702088.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902717487.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902729303.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902731447.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902787007.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902787655.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*can,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902801303.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902804479.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,yx*canvasElement.width];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902807950.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,x*canvasElement.width];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            console.log(result);\n           \n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            const vcentroid = [x,y];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902810071.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902814774.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902816162.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n  \n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902821279.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   \n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902821935.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902835535.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902837270.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902845226.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 1 || landmark.y > 1 || landmark.z > 1)\n           return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902906726.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902908704.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902910451.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    \n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902942919.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902943775.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if ()\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902945943.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (la)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902946864.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks ==)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902948103.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks === un)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902949303.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks === function name(params) {\n      \n    })\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902950007.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks === unde)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902951343.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks === undefined)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902952871.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks === undefine)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902953591.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (landmarks)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902955416.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks)\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902957703.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) {\n      \n    }\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902961895.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) {}\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902962663.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      \n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902963831.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return \n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902969456.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0]\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    console.log(landmarks);\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902972263.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902975010.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    console.log(video.style.width)\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902981822.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902990754.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902991998.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902998055.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903000263.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903002038.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n      acc[0] = landmark.x + acc[y];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903073515.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n      acc[0] = landmark.x + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903074479.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[0] = landmark.x + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903076446.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.x + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903078014.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903079847.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903081184.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n      \n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903091148.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if \n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903092444.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if ()\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903093345.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (acc)\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903094676.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.)\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903097249.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.x < 1)\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903099044.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.x < 1) {\n          \n        }\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903101043.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.x < 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903104042.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.1 < 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903106521.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.1 <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903107412.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903108389.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903111827.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903115272.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903116411.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n  video.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903198206.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n  video.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903199337.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903201008.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px; height: 720px; width: 1280px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nasync function predictWebcam() {\n    video.style.height = videoHeight;\n    canvasElement.style.height = videoHeight;\n    canvasElement.style.width = videoWidth;\n    video.style.width = videoWidth;\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903204040.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903204843.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903205941.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n          \n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903252132.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903252906.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\n  video.play();\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903256025.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903257160.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903258261.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903262702.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903265638.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903266696.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\n  let lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903269538.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903270892.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0]\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903443329.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903444132.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903445543.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n          acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903447808.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903448428.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n      \n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903449868.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x >= 0 && landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1)\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903451933.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x >= 0 && landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903456126.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x > 0 && landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903457967.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 && landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903458735.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903461535.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x || 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903463803.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 && landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903464943.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y >= 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903467168.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 && landmark.y <= 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903469400.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 && landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903471699.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nlet lastVideoTime = -1;\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        acc[0] = landmark.x + acc[0];\n        if (landmark.y <= 1) {\n          acc[1] = landmark.y + acc[1]; \n        }\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n  \nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903498239.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903504303.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903506095.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903507296.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903517444.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n  let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903569103.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903569757.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n      validLandmarksCount\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903573956.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903574625.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903575799.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903576391.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / landmarks.length);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903580457.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903581542.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount ? sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903592088.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount ? sum.map(coord => coord / validLandmarksCount) ;\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903592887.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount ? sum.map(coord => coord / validLandmarksCount) : ;\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903593886.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount === 0 ? sum.map(coord => coord / validLandmarksCount) : ;\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903597752.05
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : ;\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903599637.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return sum.map(coord => coord / validLandmarksCount);\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903601924.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903603261.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903639924.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903647578.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n      acc[1] = landmark.y + acc[1];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903649105.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n      acc[1] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903649872.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n         acc[1] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903650781.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[1] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903651643.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1]; \n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903653139.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903654273.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || )\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903663876.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903665743.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z )\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903666781.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 )\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903669272.03
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903671867.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z )\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903674607.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903676117.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903678222.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903680349.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903681710.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1 || landmark.z < 0 || landmark.z > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903682567.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903696824.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.< + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903866457.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark. + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903867660.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.z + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903868183.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903870757.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x;\n        acc[1] = landmark.y;\n        acc[2] = landmark.z + acc[2;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904021663.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x;\n        acc[1] = landmark.y;\n        acc[2] = landmark.;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904022398.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x;\n        acc[1] = landmark.y;\n        acc[2] = landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904023125.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] = landmark.y;\n        acc[2] = landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904025733.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] = landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904026461.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904027904.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n  minPoseDetectionConfidence\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904217141.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n  minPoseDetectionConfidence: \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904217885.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n  minPoseDetectionConfidence: 0.7\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904218805.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.7\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904219917.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.7,\n  \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904221085.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.7,\n      \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904226541.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n      \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904228181.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904228693.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904229221.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904230925.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904231493.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n  minTrackingConfidence\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904236293.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904237045.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: \n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904238261.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] = landmark.x + acc[0];\n        acc[1] = landmark.y + acc[1];\n        acc[2] = landmark.y + acc[2];\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904239445.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904242117.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904243663.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904261824.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904352933.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904353918.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904355875.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 1
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906010540.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);/\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906084574.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906086166.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            \n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906150358.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            \n            \n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906176205.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n            \n            \n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906185405.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n            \n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906188959.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            const [x,y,z] = calculateCentroid(result.landmarks[0]);\n            const vcentroid = [x*canvasElement.width,y*canvasElement.height];\n            canvasCtx.beginPath();\n            canvasCtx.fillStyle='white';\n            canvasCtx.arc(vcentroid[0], vcentroid[1], 10, 0, 2*Math.PI, true);\n            canvasCtx.fill();\n            canvasCtx.restore();\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 1,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906189797.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906220238.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906233846.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906235415.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906271963.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906276056.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n            environment.centroid = calculateCentroid(result.landmarks[0])\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906278128.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n            environment.centroid = calculateCentroid(result.landmarks[0])\n      });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906279133.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n            environment.centroid = calculateCentroid(result.landmarks[0])\n       });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906279922.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n            environment.centroid = calculateCentroid(result.landmarks[0])\n       );\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906281156.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0])\n       );\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906282333.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0])\n);\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906284985.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906286317.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906302893.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906304269.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\n\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906316317.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906316898.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n  \nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906320549.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906321482.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906324061.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\n    const peerId = new URL(window.location).searchParams.get(\"peer\");\n   const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n   const videoElement = document.getElementById(\"peerjs\");\n   peer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906409981.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peer\");\n   const stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n   const videoElement = document.getElementById(\"peerjs\");\n   peer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906412333.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peer\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\n   const videoElement = document.getElementById(\"peerjs\");\n   peer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906413597.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peer\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\n   peer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906414909.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peer\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906415757.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peer\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906417221.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"ps\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906420117.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"pp\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906437725.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906438509.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"guests\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906446733.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => videoElement.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906454045.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => video.srcObject = peerStream);\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906491403.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {});\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906499269.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream\n});\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906500237.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play;\n});\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906503381.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play()\n});\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906504101.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906505981.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906507541.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906509125.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\nconst videoElement = document.getElementById(\"peerjs\");\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906530830.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906534749.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: \" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906596685.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906598229.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906644533.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": "<video id=\"webcam\" style=\"width: 1280px; height: 720px; position: abso\" autoplay=\"\" playsinline=\"\" width=\"1280\" height=\"720\"></video>\n<canvas class=\"output_canvas\" id=\"output_canvas\" width=\"1280\" height=\"720\" style=\"position: absolute; left: 0px; top: 0px;\"></canvas>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\nconst video = document.getElementById(\"webcam\");\nconst canvasElement = document.getElementById(\"output_canvas\");\nconst canvasCtx = canvasElement.getContext(\"2d\");\nconst videoHeight = \"720px\";\nconst videoWidth = \"1280px\";\nconst stream = await navigator.mediaDevices.getUserMedia({video: true,audio: false});\nvideo.srcObject = stream;\nvideo.play();\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nvideo.width = parseInt(videoWidth, 10);\ncanvasElement.width = parseInt(videoWidth, 10);\nvideo.height = parseInt(videoHeight, 10);\ncanvasElement.height = parseInt(videoHeight, 10);\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {\n            canvasCtx.save();\n            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n            environment.centroid = calculateCentroid(result.landmarks[0]);\n        });\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>"
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906661836.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907512317.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n          environment.centroid = calculateCentroid(result.landmarks[0]));\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907628773.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n          environment.centroid = calculateCentroid(result.landmarks[0])\n                                     );\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907629941.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "<video id=\"webcam\" style=\"width: 1280px; height: 720px;\" autoplay playsinline></video>\n<script type=\"module\">\nimport {PoseLandmarker,FilesetResolver,DrawingUtils} from \"https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0\";\nconst vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm\");\nconst poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n    baseOptions: {\n        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task`,\n        delegate: \"GPU\"\n    },\n    runningMode: \"video\",\n    numPoses: 1,\n    minPoseDetectionConfidence: 0.8,\n    minPosePresenceConfidence: 0.8,\n    minTrackingConfidence: 0.8\n});\n\nconst video = document.getElementById(\"webcam\");\nconst peerId = new URL(window.location).searchParams.get(\"peers\");\nconst stream = await navigator.mediaDevices.getUserMedia({video: true, audio: false});\npeer.call(peerId, stream).on('stream', peerStream => {\n  video.srcObject = peerStream;\n  video.play();\n});\n  \nfunction calculateCentroid(landmarks) {\n    if (!landmarks) \n      return [0,0,0];\n    let validLandmarksCount = 0;\n    const sum = landmarks.reduce((acc, landmark) => {\n        if (landmark.x < 0 || landmark.x > 1 || landmark.y < 0 || landmark.y > 1)\n            return acc;\n        acc[0] += landmark.x;\n        acc[1] += landmark.y;\n        acc[2] += landmark.z;\n        validLandmarksCount++;\n        return acc;\n    }, [0, 0, 0]);\n    return validLandmarksCount > 0 ? sum.map(coord => coord / validLandmarksCount) : [0,0,0];\n}\n\nlet lastVideoTime = -1;\nasync function predictWebcam() {\n    let startTimeMs = performance.now();\n    if (lastVideoTime !== video.currentTime) {\n        lastVideoTime = video.currentTime;\n        poseLandmarker.detectForVideo(video, startTimeMs, (result) => \n          environment.centroid = calculateCentroid(result.landmarks[0])\n        );\n    }\n   window.requestAnimationFrame(predictWebcam);\n}\nvideo.addEventListener(\"loadeddata\", predictWebcam);\n</script>",
                      "language": "html",
                      "output": ""
                    },
                    "index": 2,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907632084.05
          }
        ]
      ],
      "hash": "00c6da52228eef8fc72bf35af8be0a91491e83ffba68ed338d5423b4fe919b83"
    },
    "_meta": {
      "lwt": 1684907632089.01
    },
    "_deleted": false,
    "_attachments": {},
    "_rev": "556-qwmnxojdkk"
  },
  {
    "id": "AWDZJNAGMo",
    "type": "code",
    "data": {
      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark detection\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
      "language": "javascript",
      "output": ""
    },
    "index": 3,
    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1",
    "crdts": {
      "operations": [
        [
          {
            "creator": "fgdfoknmow",
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "id": "AWDZJNAGMo",
                    "type": "code",
                    "data": {
                      "code": "",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 2,
                    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1"
                  }
                }
              }
            ],
            "time": 1684906204582.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 4
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906271970.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/1-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907533508.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907537931.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\nif ()\n\n// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907554772.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\nif (current)\n\n// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907557396.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\nif (currentUrl.)\n\n// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907559052.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\n\n\n// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907563469.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\n\n\n// Generate new token on https://github.com/settings/tokens// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907564756.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "\n// Generate new token on https://github.com/settings/tokens\n// It saves your token locally, so you need not generate new token.\nenvironment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907566284.04
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replication.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907570300.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-server-replicatio.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907574315.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907575683.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc+.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907578956.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907580787.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907583868.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907584828.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-p.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907585732.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-med.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907586708.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907588004.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907589739.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your token\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907594067.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: replicate to GitHub and remove your toke\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907596347.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: \",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907598564.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907603843.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907607011.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark de\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907608124.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark detection\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907609515.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark detection\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": "Uncaught Error: Error while fetching the file\n"
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907678028.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\nenvironment.GITHUB_TOKEN",
                      "language": "javascript",
                      "output": "Uncaught Error: Error while fetching the file\n"
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907687740.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\nenvironment.GITHUB_TOKEN",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907688291.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\nenvironment.GITHUB_TOKEN",
                      "language": "javascript",
                      "output": "REPLACE YOUR TOKEN HERE"
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907688971.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark detection\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": "REPLACE YOUR TOKEN HERE"
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907690371.06
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "data": {
                      "code": "environment.GITHUB_TOKEN = environment.GITHUB_TOKEN || \"REPLACE YOUR TOKEN HERE\"\nawait environment.wait()\n\neditor.blocks.get$.pipe(\n  first(),\n  map(content =>\n    btoa(unescape(encodeURIComponent(JSON.stringify(content, null, 2).replaceAll(environment.GITHUB_TOKEN, \"\"))))),\n  commitOnGitHub({\n    owner: \"sanchezcarlosjr\",\n    repo: \"computer-vision-and-graphics\",\n    filePath: \"assets/evanotebooks/11-webrtc-and-mediapipe-pose-landmarks.json\",\n    commitMessage: \"feat: real time pose landmark detection\",\n    GITHUB_TOKEN: environment.GITHUB_TOKEN\n   }\n  )\n)",
                      "language": "javascript",
                      "output": ""
                    },
                    "index": 3,
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "_deleted": false
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684907767627.02
          }
        ]
      ],
      "hash": "377d58e3fc0621e890805d592ffef37c900440cb6118943ba851593b8e94e400"
    },
    "_meta": {
      "lwt": 1684907767629.01
    },
    "_deleted": false,
    "_attachments": {},
    "_rev": "38-qwmnxojdkk"
  },
  {
    "id": "qmM9D9Se-W",
    "type": "paragraph",
    "data": {
      "text": ""
    },
    "index": 4,
    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1",
    "crdts": {
      "operations": [
        [
          {
            "creator": "fgdfoknmow",
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "id": "qmM9D9Se-W",
                    "type": "paragraph",
                    "data": {
                      "text": ""
                    },
                    "index": 2,
                    "createdBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "topic": "4f6a1a2a-cca9-448f-9d97-1dfa41c565f1"
                  }
                }
              }
            ],
            "time": 1684901564263.02
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902845232.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684902998059.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903111834.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903504314.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903680356.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684903870764.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684904261830.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 2
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906010548.01
          }
        ],
        [
          {
            "body": [
              {
                "ifMatch": {
                  "$set": {
                    "lastEditedBy": "bb3afb0b-04d3-4e58-8a32-552a1d3e7695",
                    "index": 5
                  }
                }
              }
            ],
            "creator": "fgdfoknmow",
            "time": 1684906271970.03
          }
        ]
      ],
      "hash": "665c5a0ae6e2ecbeb8ae104578640852b34e4489cebb4dc50c295d55cac6719e"
    },
    "_meta": {
      "lwt": 1684907515313.02
    },
    "_deleted": false,
    "_attachments": {},
    "_rev": "15-qwmnxojdkk"
  }
]