---
layout: default
title:  "Exercise 7 - Julia Set"
---
<style>
    section {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        flex-direction: column;
    }

    canvas {
        aspect-ratio: 1 / 1;
        width: 50%;
        max-height: 50%;
        border: none;
        padding: 0;
        margin: 0;
    }

    textarea {
        width: 100%;
        line-height: 12px;
        font-size: 12px;
        padding: 0.5em 0.5em;
        margin-bottom: 1em;
    }
</style>

<p>Press Enter to execute. Check out <a href="https://mathjs.org/docs/index.html">Mathjs</a> to use Complex numbers and another math. </p>
<div id="error"></div>
<textarea id="code" rows="6">
globalThis.c = math.evaluate('0.7885e^i');
globalThis.f = function(complex) {
    return complex.mul(complex).add(globalThis.c);
}
globalThis.pseudoInfinity = 100;
globalThis.iterations = 4;
    </textarea>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.6.0/lib/browser/math.min.js"></script>
<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three/build/three.module.js"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';

    globalThis.c = math.evaluate('0.7885e^i');
    globalThis.complexFunction = (complex) => complex.mul(complex).add(globalThis.c)
    globalThis.threshold = 100;
    globalThis.iterations = 4;
    globalThis.n = 1000;
    globalThis.m = 1000;
    globalThis.num = 1500;

    function matrix(m = 60, n = 60, num = 60, start = -5, stop = 5) {
        const step = (stop - start) / num;
        const coordinate = (i) => start + step * i;
        return Array.from({
            length: m
        }, (_, i) => Array.from({length: n}, (_, j) => new THREE.Vector3(coordinate(i), coordinate(j), 0)));
    }
    const find_possible_julia_set_element = (z) => {
        let complexNumber = globalThis?.complexFunction(new math.complex({'im': z.y, 're': z.x}));
        for (let i = globalThis?.iterations; i > 0; i--)
            complexNumber = globalThis?.complexFunction(complexNumber);
        return complexNumber;
    }

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set( 0, 0, 5 );
    camera.lookAt( 0, 0, 0 );

    const scene = new THREE.Scene();

    const material = new THREE.LineBasicMaterial( { color: 0xfffff } );

    document.getElementById('code').addEventListener('keydown', (event) => {
        if (event.key === "Enter") {
            event.preventDefault();
            const code = event.target.innerHTML.trim();
            try {
                eval(code);
            } catch (e) {
                showError(e.message);
                return;
            }
            let pixels = matrix(globalThis.m,globalThis.n,globalThis.num)
                .flat()
                .filter(pixel => find_possible_julia_set_element(pixel).abs() < globalThis.threshold)

            const geometry = new THREE.BufferGeometry().setFromPoints( pixels );
            const juliaSet = new THREE.Points( geometry, material );
            scene.add( juliaSet );
            renderer.render( scene, camera );
        }
    });

</script>
