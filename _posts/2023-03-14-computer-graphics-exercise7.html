---
layout: default
title:  "Exercise 7 - Julia Set"
---
<style>
    section {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        flex-direction: column;
    }

    canvas {
        aspect-ratio: 1 / 1;
        width: 50%;
        max-height: 50%;
        border: none;
        padding: 0;
        margin: 0;
    }

    textarea {
        width: 100%;
        line-height: 12px;
        font-size: 12px;
        padding: 0.5em 0.5em;
        margin-bottom: 1em;
    }
</style>

<section>
    <p>Press Enter to execute. Check out <a href="https://github.com/infusion/Complex.js">ComplexJS</a> to use Complex numbers. </p>
    <div id="error"></div>
    <textarea id="code" rows="6">
         globalThis.c = 0;
         globalThis.f = function(complex) {
            return complex.mul(complex).add(globalThis.c);
         }
         globalThis.pseudoInfinity = 100;
         globalThis.iterations = 10;
    </textarea>
    <canvas id="gl-canvas">Your browser does not seem to support HTML canvas.</canvas>
</section>

<script src="https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js"></script>
<script src="https://interactivecomputergraphics.com/Code/Common/initShaders.js"></script>
<script src="https://interactivecomputergraphics.com/Code/Common/MVnew.js"></script>

<script id="black-fragment-shader" type="x-shader/x-fragment">
 #version 300 es
 precision mediump float;
 out vec4 fColor;
 void main() {
     fColor = vec4(0,0,0,1.0);
 }
</script>

<script id="vertex-shader" type="x-shader/x-vertex">
 #version 300 es
 in vec4 aPosition;
 void main() {
    gl_Position = aPosition;
 }
</script>


<script type="module">
    const {last, of, filter, map} = rxjs;
    import complexJs from 'https://cdn.jsdelivr.net/npm/complex.js@2.1.1/+esm'
    globalThis.c = 0;
    globalThis.f = (complex) => complex.mul(complex).add(globalThis.c);
    globalThis.pseudoInfinity = 100;
    globalThis.iterations = 10;
    globalThis.n = 100;
    globalThis.m = 100;
    globalThis.num = 60;
    function matrix(m = 60, n = 60, num = 60, start = -1, stop = 1) {
        const step = (stop - start) / num;
        const f = (i) => start + step * i;
        return Array.from({
            length: m
        }, (_, i) => Array.from({length: n}, (_, j) => vec2(f(i), f(j))));
    }
    const find_possible_julia_set_element = (z) => {
        let complex = new complexJs.Complex({'im': z[1], 're': z[0]});
        for (let i = globalThis?.iterations; i > 0; i--)
            complex = globalThis?.f(complex);
        return complex;
    }
    function showError(message) {
        document.getElementById('error').innerHTML = message;
    }
    const closure = (op) => (ob) => {
        if (ob) op(ob);
        return ob;
    };
    const f = (pixels) => of(document.getElementById('gl-canvas')).pipe(
        filter(canvas => !!canvas),
        map(canvas => closure(({gl}) => {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(1, 1, 1, 1);
            })({gl: canvas.getContext('webgl2'), objects: []}) ?? error("WebGL 2.0 isn't available.")
        ),
        map(({gl, objects}) => {
            const program = initShaders(gl, "vertex-shader", "black-fragment-shader");
            gl.useProgram(program);
            const bufferId = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(pixels), gl.STATIC_DRAW);
            const aPosition = gl.getAttribLocation(program, "aPosition");
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPosition);
            objects.push({render: () => gl.drawArrays(gl.POINTS, 0, pixels.length)});
            return {gl, objects};
        }));
    document.getElementById('code').addEventListener('keydown', (event) => {
        if (event.key === "Enter") {
            event.preventDefault();
            const code = event.target.innerHTML.trim();
            try {
                eval(code);
            } catch (e) {
                showError(e.message);
                return;
            }
            let pixels = matrix(globalThis.m,globalThis.n,globalThis.num).flat();
            f(
                pixels.filter(pixel => find_possible_julia_set_element(pixel).abs() < globalThis.pseudoInfinity)
            ).subscribe(({gl, objects}) => {
                gl.clear( gl.COLOR_BUFFER_BIT );
                objects.forEach(obj => obj.render?.());
            })
        }
    });
</script>
